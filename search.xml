<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo--第二弹]]></title>
    <url>%2F2019%2F07%2F10%2FHexo-%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[目录 1. Hexo支持流程图、时序图 2. Hexo多行代码提供复制 3. Hexo复制时追加版权 Hexo支持流程图、时序图画流程图还需要用别的编辑器画了用图片导入？Hexo实现手写流程图也很简单哦，但是有个小坑，小编被坑了好久，接下来手把手👇带你们过坑。 markdown语法实现流程图的方式可以通过mermaid或flowchart，时序图则可以mermaid或sequence，但是默认是不会识别语法的，只是当做普通的多行代码，需要安装插件。 方式一：mermaid支持流程图（graph）、时序图（sequenceDiagram）、甘特图（gantt），可以说支持很多了。配置教方式二麻烦一点。 在线编辑器地址：https://mermaidjs.github.io/mermaid-live-editor/ ，可以利用在线编辑器编辑完流程图之后，下载SVG或者直接link。 安装官方说的是通过yarn安装（如果没有安装yarn，使用npm install -g yarn安装）1$ yarn add hexo-filter-mermaid-diagrams 也可以使用npm：1$ npm i hexo-filter-mermaid-diagrams 插件的官方网址 配置（1）修改站点配置文件_config.yml在最后加入123456# mermaid chart mermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: "7.1.2" # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true （2）Next主题更改：在themes/next/_partials/footer.swig 最后加入12345678&#123;% if theme.mermaid.enable %&#125; &lt;script src='https://unpkg.com/mermaid@&#123;&#123; theme.mermaid.version &#125;&#125;/dist/mermaid.min.js'&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: 'default'&#125;); &#125; &lt;/script&gt;&#123;% endif %&#125; 主题可更改，包含 default | forest 重新hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug启动渲染也生效了。 示例1. 流程图示例 ```mermaidgraph TB start(开始)–&gt;inputA[输入用户名密码] inputA–&gt;opA{数据库查询子类} opA–&gt;conditionA{是否有此用户} conditionA–yes–&gt;conditionB{密码是否正确} conditionA–no–&gt;inputA conditionB–yes–&gt;opB[读入用户信息] conditionB–no–&gt;inputA opB–&gt;en(登录) ``` mermaid流程图展示： graph TB start(开始)-->inputA[输入用户名密码] inputA-->opA{数据库查询子类} opA-->conditionA{是否有此用户} conditionA--yes-->conditionB{密码是否正确} conditionA--no-->inputA conditionB--yes-->opB[读入用户信息] conditionB--no-->inputA opB-->en(登录) 2. 时序图示例 ```mermaidsequenceDiagramparticipant Clientparticipant Server Note left of Client:SYN_SENTClient-&gt;Server:SYN=1 seq=xNote right of Server:SYN_RCVDServer-&gt;Client:SYN=1 seq=y ACK=x+1Note left of Client:ESTABLISHEDClient-&gt;Server:ACK=y+1Note right of Server:ESTABLISHED``` mermaid时序图展示： sequenceDiagram participant Client participant Server Note left of Client:SYN_SENT Client->Server:SYN=1 seq=x Note right of Server:SYN_RCVD Server->Client:SYN=1 seq=y ACK=x+1 Note left of Client:ESTABLISHED Client->Server:ACK=y+1 Note right of Server:ESTABLISHED 要说的话mermaid帮助文档：https://mermaidjs.github.io/ ，可在里面查看更多的使用介绍及语法。 优点：颜色鲜艳；语法结构简单，不需要先声明；方向可指定；灵活，可以更改样式。 缺点：方块模式提供没有标准流程图的规范的形状，比如输入框的平行四边形是没有的，需要自定义；加载渲染较慢，会出现展示多行代码样式。···mermaidgraph LRid1&gt;id1]–&gt;id2[id2]id2—id3(id3)id3—|text|id4((id4))id4–&gt;|text|id5{id5} style id1 fill:#f9f,stroke:#333,stroke-width:4pxstyle id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5··· graph LR id1>id1]-->id2[id2] id2---id3(id3) id3---|text|id4((id4)) id4-->|text|id5{id5} style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5 更多流程图使用查看：https://mermaidjs.github.io/flowchart.html 流程图过长会占用界面大部分空间，博客中设置了最大高度，及居中展示，在themes/next/source/css/_custom/custom.styl下面加入12345/*mermaid图居中*/.mermaid&#123; text-align: center; max-height: 300px;&#125; 方式二：flowchart+sequence安装支持流程图，安装：1$ npm install --save hexo-filter-flowchart 支持时序图，安装：1$ npm install --save hexo-filter-sequence 配置（非必须）插件官方地址： flowchart sequence 官方配置提到需要更改站点配置文件_config.yml，增加：1234567891011121314flowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG` sequence: # webfont: # optional, the source url of webfontloader.js # snap: # optional, the source url of snap.svg.js # underscore: # optional, the source url of underscore.js # sequence: # optional, the source url of sequence-diagram.js # css: # optional, the url for css, such as hand drawn theme options: theme: css_class: 亲测不配置也是可以的。hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug启动渲染也生效了。 示例1.流程图示例 ```flowst=&gt;start: 开始inputA=&gt;inputoutput: 输入用户名密码opA=&gt;operation: 数据库查询子类conditionA=&gt;condition: 是否有此用户conditionB=&gt;condition: 密码是否正确opB=&gt;operation: 读入用户信息e=&gt;end: 登录st-&gt;inputA-&gt;opA-&gt;conditionAconditionA(yes)-&gt;conditionBconditionA(no)-&gt;inputAconditionB(yes)-&gt;opB-&gt;econditionB(no)-&gt;inputA``` flowchart流程图展示： 2.时序图示例 ```sequenceparticipant Clientparticipant Server Note left of Client:SYN_SENTClient-&gt;Server:SYN=1 seq=xNote right of Server:SYN_RCVDServer-&gt;Client:SYN=1 seq=y ACK=x+1Note left of Client:ESTABLISHEDClient-&gt;Server:ACK=y+1Note right of Server:ESTABLISHED``` sequence时序图展示： 要说的话优点：标准流程图的样式展示；渲染快，几乎不会出现展示多行代码的时候；实现简单。 缺点：样式不能更改，黑白界面；流程图语法需要先声明后使用。 设置最大高度及居中展示，背景色，超出部分滑动：12345678910111213.flow-chart &#123; text-align: center; max-height: 300px; overflow: auto; background: #f7f7f7;&#125;.sequence &#123; text-align: center; max-height: 300px; overflow: auto; background: #f7f7f7;&#125; sequence的小编不走心，没有提供class，需要在node_modules/hexo-filter-sequence/lib/renderer.js修改，大约22行，设置id的时候同时增加class：1return start + '&lt;div id="' + seqId + '" class="sequence"&gt;&lt;/div&gt;' + end; 特别注意：很多人说sequence设置无效，需要更改依赖的snap为raphael，也有说更改站点配置文件的external_link为false，小编都试过了，无效。为啥子时序图还是失败了呢？小编搜了整个项目差点以为是跟motion.js里面的sequence重合有缺陷，都打算改插件了，然而并不需要！！如果您的使用的Hexo，而且时序图放在md文件的最后一个，导致渲染失效了的话，请在文章的最后输入一个回车，没错就是只需要一个回车就解决了。。不知道是不是Hexo的bug，所有的多行代码在文章末尾的都会出现渲染问题，并不是sequence的问题。 Hexo多行代码提供复制增加复制按钮及响应的js：1234567891011121314clipboard.jsvar initCopyCode = function () &#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function (trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; 资源下载：clipboard.js clipboard-use.js 下载完成后，将clipboard.js和clipboard-use.js放在 themes/next/source/js/src/下，并更改themes/next/layout/_layout.swig，在上面加入123&lt;!--代码块复制功能--&gt;&lt;script type='text/javascript' src='/js/src/clipboard.js'&gt;&lt;/script&gt;&lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 这样在鼠标在代码区域时右上角显示copy。 Hexo复制时追加版权虽然在主题配置文件_config.yml中更改post_copyright可以在文章底部增加版权声明信息，复制时并不能像很多博客网站一样复制时直接追加。 实现是通过监听copy事件，追加信息：123456789101112131415161718192021222324252627282930copyright.js(() =&gt; &#123; if (document.getElementsByClassName("post-copyright").length&gt;0) &#123; const author=document.getElementsByClassName("author")[0].textContent; document.addEventListener('copy', e =&gt; &#123; let clipboardData = e.clipboardData || window.clipboardData; if(!clipboardData) &#123; return; &#125; e.preventDefault(); const selection = window.getSelection().toString(); const textData = selection + '\n-----------------------\n' + (author ? `作者: $&#123;author&#125;\n` : '') + '原文: ' + window.location.href + '\n' + '版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！\n\n'; const htmlData = selection + '&lt;br/&gt;-----------------------&lt;br/&gt;' + (author ? `&lt;b&gt;作者&lt;/b&gt;: $&#123;author&#125;&lt;br/&gt;` : '') + `&lt;b&gt;原文&lt;/b&gt;: &lt;a href="$&#123;window.location.href&#125;"&gt;$&#123;window.location.href&#125;&lt;/a&gt;&lt;br/&gt;` + '版权声明：本博客所有文章除特别声明外，均采用 &lt;a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"&gt;CC BY-NC-SA 3.0&lt;/a&gt; 许可协议。转载请注明出处！&lt;br/&gt;'; clipboardData.setData('text/html', htmlData); clipboardData.setData('text/plain', textData); &#125;); &#125;&#125;)(); 资源下载：copyright.js下载完成后，copyright.js放在 themes/next/source/js/src/下，并更改themes/next/layout/_layout.swig，在上面加入12&lt;!--&#123;#复制版权申明#&#125;--&gt;&lt;script type="text/javascript" src="/js/src/copyright.js"&gt;&lt;/script&gt; 版权开启时，复制时即可增加版权信息。 st=>start: 开始 inputA=>inputoutput: 输入用户名密码 opA=>operation: 数据库查询子类 conditionA=>condition: 是否有此用户 conditionB=>condition: 密码是否正确 opB=>operation: 读入用户信息 e=>end: 登录 st->inputA->opA->conditionA conditionA(yes)->conditionB conditionA(no)->inputA conditionB(yes)->opB->e conditionB(no)->inputA{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);participant Client participant Server Note left of Client:SYN_SENT Client->Server:SYN=1 seq=x Note right of Server:SYN_RCVD Server->Client:SYN=1 seq=y ACK=x+1 Note left of Client:ESTABLISHED Client->Server:ACK=y+1 Note right of Server:ESTABLISHED{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排除aar/jar中冗余或者冲突包、类的脚本]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%8E%92%E9%99%A4aar-jar%E4%B8%AD%E5%86%97%E4%BD%99%E6%88%96%E8%80%85%E5%86%B2%E7%AA%81%E5%8C%85%E3%80%81%E7%B1%BB%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[引入aar的冲突无所不在，通过远程依赖maven的包可以通过exclude关键字搭配module和group去除某个组，没办法去除具体的类。 那么如果是单独的aar包，想要排除aar下classes.jar包里的某个单独的包或者类怎么办？ 需要接入的jar包已经带了腾讯X5核心，当前依赖的已经包含X5核心，冲突又该如何解决呢？ 当前的gradle脚本（项目链接：https://github.com/luohongxfb/ExcludeAar ）可以解决。 目录 1 效果展示 2 如何使用 3 如何实现的 解压AAR/JAR包 按照排除规则对解压的jar重新打包(这个是重点) 重新打包成AAR包 1 效果展示如excludelib/libs/exampleAAR.aar，左边是未去除的包结构，右边是去除com.baidu之后的： 如excludelib/libs/exampleJAR.jar： 2 如何使用（1）将需要排除的aar或者jar包放在excludelib/libs下。 （2）更改excludelib/build.gradle123//需要排除的aar或者jar。（替换成需要排除的）artifacts.add("exclude", file('libs/exampleAAR.aar'))artifacts.add("exclude", file('libs/exampleJAR.jar')) （3）设置排除规则 如果您需要排除aar，那么请更改excludelib/excludeAar.gradle；如果您需要排除jar，那么请更改excludelib/excludeJar.gradle1234//需要排除的包名def excludePackages = ['com.baidu']//需要排除的类(需要全类名)def excludeClasses = [] （4）运行排除任务 排除后生成的aar在excludelib/build/excludeaar下，排除后生成的jar位于excludelib/build/excludejar。 然后就可以愉快的使用啦~ 3 如何实现的aar排除步骤： 1、获取到需要排除的原始AAR包 2、解压AAR包（zipTree配合Task Copy） 3、解压AAR包中的class.jar（zipTree配合Task Copy） 4、按照排除规则对解压的class.jar重新打包(Task Jar) 5、重新打包成AAR包(Task Zip) jar排除步骤 1、获取到需要排除的原始jar包 2、解压jar包（zipTree配合Task Copy） 3、按照排除规则对解压的jar重新打包(Task Jar) 解压AAR/JAR包123456task unZipAar(type: Copy) &#123; def zipFile = getDefaultAar() def outputDir = unZipAarFile from zipTree(zipFile) into outputDir&#125; 主要原理：zipTree配合Copy，实现解压。 Copy Task官方讲解：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.Copy.html ziptree源码主要解析：创建一个新的file tree包含原来zip的内容，可以配合Copy实现解压。12345678910public interface Project&#123; /** * &lt;p&gt;Creates a new &#123;@code FileTree&#125; which contains the contents of the given ZIP file. * You can combine this method with the &#123;@link #copy(groovy.lang.Closure)&#125; * method to unzip a ZIP file * @param zipPath The ZIP file. Evaluated as per &#123;@link #file(Object)&#125;. * @return the file tree. Never returns null. */ FileTree zipTree(Object zipPath);&#125; 按照排除规则对解压的jar重新打包(这个是重点)1234567task zipJar(type: Jar) &#123; baseName = 'classes' from unZipJarFile destinationDir unZipAarFile exclude getExcludePackageRegex(excludePackages) exclude getExcludeClassRegex(excludeClasses)&#125; 这个步骤就是把之前解压的classes.jar文件，按照排除规则用Task Jar重新打包成jar文件。 Task Jar官方讲解：https://docs.gradle.org/current/dsl/org.gradle.jvm.tasks.Jar.html Property/Method Description baseName 压缩后的jar文件名。 from(sourcePaths) 需要压缩的目录。 destinationDir 压缩后存放的目录。 exclude(excludes) 需要排除的文件。 重新打包成AAR包12345678task excludeAar(type: Zip) &#123; group 'ex' description '生成一个排除之后的aar包' baseName excludeAarName extension "aar" from unZipAarFile destinationDir excludeAarFile&#125; 对classes.jar处理完成的aar重打包，主要用到Task Zip。 Task Zip官方讲解：https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Zip.html Property/Method Description group setGroup(String group) 将当前的Task设置到指定组。 description setDescription(@Nullable String description) Task描述。 baseName 压缩后的aar文件名。 extension 压缩后的文件扩展名。 from(sourcePaths) 需要压缩的目录。 destinationDir 压缩后存放的目录。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo--第一弹]]></title>
    <url>%2F2019%2F07%2F04%2FHexo-%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[目录 1. 不渲染.md或者layout 2. 新建文件草稿 1. 不渲染.md或者layoutHexo 在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染，我们想给输出项目添加一个README.md文件，不想被渲染，保持markdown文件格式，不转换为html怎么办呢 不渲染html在头部添加Front-matter。.md还是会转换成.html，但是不会渲染样式。单纯只是标签。1234---layout: false--- .md还是被转换成了.html，但是没有渲染。想要自定义样式的.html文件可参考设置，但是还不符合我们的期望，我们想要的保持.md样式呀。 不渲染.md文件在站点配置文件_config.yml查找skip_render，设置需要跳过渲染的文件。 设置不被渲染的是source/README.md和source/test/a.html 1234#跳过渲染 相对目录是`source`目录skip_render: - README.md - test/a.html 在public目录可以看见我们的目的达到了~ 2. 新建文件草稿当我们有的文章没写完，或者暂时不想展示时，可以新建草稿。在项目目录下终端12//新建草稿$ hexo new draft &quot;草稿&quot; 在source/_drafts会生成一个 草稿.md文件，这个文件不会显示在页面上，链接也访问不到。想要渲染草稿需要在站点配置文件_config.yml查找render_drafts，设置为true。12//如果你希望强行预览草稿，更改配置文件：render_drafts: true 注意：改为true之后，deploy线上部署也会显示，不需要的时候务必改成false。将草稿发布，转换到source/_posts下：12//发布草稿$ hexo publish [草稿]]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最完善的markdown转html/pdf方法、带目录生成]]></title>
    <url>%2F2019%2F07%2F04%2Fmarkdown%E8%BD%AChtml%E3%80%81pdf-%E5%B8%A6%E7%9B%AE%E5%BD%95%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[最近小编需要写个SDK接入文档，用word调格式当然不如markdown来的舒服，写起来舒服了，但是.md没办法直接看效果，最终萌生出把markdown转成html形式的想法。 网上markdown转换html的方法有很多，包括在线转换和借助工具，最终小编选择了VisualStudio Code的插件Markdown Preview Enhanced。 目录 1.在线转换的网站 2.借助工具 2.1 typora 2.2 i5ting_toc 2.3 VisualStudio Code插件 插件1：copy Markdown as HTML 插件2：Markdown+Math 插件3：Markdown Preview Enhanced （推荐） 1.在线转换的网站 http://www.bejson.com/convert/html2markdown/ ：不支持表格，不推荐 http://www.atool9.com/html2markdown.php ：不支持表格，不推荐 https://www.zai17.com/md2html/ ：```{代码}```包含的代码处理不太理想，不推荐 https://github.com/markedjs/marked ：转换结果比较理想，渲染需更改。可以用Demo Page查看效果。渲染可以使用github-markdown-css，github风格。 …（在线的还有很多，反正小编没有找到理想的） 2.借助工具2.1 typora官网下载。很多人说好用。Q@Q原谅小编没使明白。 2.2 i5ting_toc解析渲染ok，可自动生成侧边目录，不可以编写过程中实时预览，生成的侧边栏不更改本身.md文件，附带的样式太多。依赖Node环境，通过npm install i5ting_toc -g安装，等待安装完成。 输入i5ting_toc -h回车查看帮助。 转换html，输入i5ting_toc -f [需要转换文件名].md默认在同级目录生成preview文件夹，打开preview下的同名.html文件或者直接i5ting_toc -o可预览。 2.3 VisualStudio Code插件需要先安装VisualStudio Code。右键.md选择打开方式为VisualStudio Code。下载插件转换。 插件1：copy Markdown as HTMLCtrl+Shift+P（MacOS：cmd+shift+p）呼出命令面板。输入markdown:copy as html选中，复制到剪切板，新建一个.html文件，粘贴修改。转换结果比较理想，渲染需更改 插件2：Markdown+MathCtrl+Shift+P（MacOS：cmd+shift+p）呼出命令面板。输入markdown:clip markdown+math to html选中，同样复制到剪切板，需要新建一个.html文件，粘贴修改。转换结果比较理想，渲染需更改 插件3：Markdown Preview Enhanced （推荐）历经千辛万苦，小编终于找到了懒人的福音，可以一键生成目录、输出html/pdf的强大markdown插件–Markdown Preview Enhanced。详细用法点击查看官网。 多种特性： 自动编辑器及预览滑动同步 可导出的格式：漂亮的html、pandoc、电子书、幻灯片、PDF、 PNG、JPEG 。。 支持LaTeX 数学、流程图 / 时序图 以及各种其他种类的图形，嵌入 LaTeX, 渲染 TikZ, Chemfig 等图形 支持自定义预览 CSS 生成目录。（TOC 生成） … 这里小编介绍一下目录生成及输出html。首先安装插件：点击侧边栏最后一个Extensions，在搜索框输入Markdown Preview Enhanced，点击Install等待安装完成。 打开需要转换的.md文件，右键选择打开同步预览。 生成目录：详细讲解 光标放置想要生成目录的输出位置，Ctrl+Shift+P（MacOS：cmd+shift+p）呼出命令面板，输入Markdown Preview Enhanced: Create Toc会生成一段类似然后Ctrl+s保存，就会生成目录。注意：必须要在预览打开的情况下生成操作，保存才能更新。 输出html：在右侧的预览界面，右键点击选择HTML-&gt;HTML(offline)。在当前.md文件的同级目录会生成一个同名.html文件，解析渲染都理想~ ——————本文结束—————— 生成的html是你想要的样式吗？或者你有更好的方法欢迎联系我 更多好文欢迎关注我的公众号：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo--GitHub Pages部署]]></title>
    <url>%2F2019%2F03%2F22%2FHexo-GitHub-Pages%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[部署到GitHub Pages请先准备一个GitHub账号，没有的话，出门右转浏览器地址栏输入：https://github.com/ Sign Up开始注册 有Git账号的准备新建仓库：https://github.com/new Repository name建议填自己用户名Owner带上.github.io 注意两点： 仓库名为[Owner].github.io时才可以通过https://[Owner].github.io访问，如果不是则需要按照原来的仓库形式，即Git地址+用户名+仓库名 仓库权限必须为Public 在Hexo项目配置文件_config.yml中，拉到底部，找到deploy配置字段，1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: #前面创建的仓库地址 branch: master message: #描述 运行hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy，没设置全局用户名的可能需要输入Git用户名密码。 等待一段时间~ 完成后在仓库的Settings中，配置Source为master branch就能通过https://[Owner].github.io访问啦~ 配置域名访问在腾讯云域名（https://www.qcloud.com/act/event/dnspod_baidu?!preview ）或阿里云域名（https://wanwang.aliyun.com/domain/?spm=a2c4g.11174283.2.1.789dc8caQX0KM1 ）购买一个域名登陆管理后台，配置云解析，添加记录将想要的前缀配置CNAME规则到git域名[Owner].github.io在仓库的Settings中GitHub Pages的Custom domain填入配置的前缀+域名即可。Enforce HTTPS会强制域名访问的时候也是通过https。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo--博客搭建]]></title>
    <url>%2F2019%2F03%2F22%2FHexo--%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本站的博客搭建采用Hexo+NexT主题，部署在GitHub Pages。下面手把手带你搭建免费高效的博客系统~ 简介Hexo–快速、简洁且高效的博客框架，基于NodeJS环境。 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提： NodeJS环境：下载地址 Git：Windows | Mac 安装Hexo：1npm install -g hexo-cli 具体的安装过程的问题，这里不再过多提及。官方安装文档：https://hexo.io/zh-cn/docs/ 建站新建文件夹创建项目：123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 若需要在当前文件夹直接创建，在当前目录下hexo init。 Hexo项目目录结构：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的配置信息。官方配置文档：https://hexo.io/zh-cn/docs/configuration。 package.json：应用程序的信息。 scaffolds：模版文件夹。当您新建文章时，Hexo 会根据scaffold来建立文件。官方模板配置文档：https://hexo.io/zh-cn/docs/templates source：资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes：主题文件夹。Hexo 会根据主题来生成静态页面。 项目下的_config.yml为项目配置文件，主题下的_config.yml为主题配置文件。 执行1hexo generate &amp;&amp; hexo server --debug 即可在本地http://localhost:4000/ 查看默认的网站样式啦~ 命令新建网站项目1hexo init [folder] 如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 新建文章1hexo new [layout] &lt;title&gt; 如果没有设置 layout 的话，默认使用 网站配置_config.yml 中的 default_layout 参数代替。 如果标题包含空格的话，请使用引号括起来。 也可以简写：hexo n [layout] &lt;title&gt; 生成静态文件1hexo generate -d, –deploy 文件生成后立即部署网站 -w, –watch 监视文件变动 也可以简写：hexo g 本地启动服务器1hexo server 默认情况下，访问网址为： http://localhost:4000/。 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 也可以简写：hexo s 线上部署1hexo deploy -g, –generate 部署之前预先生成静态文件 也可以简写：hexo d 部署到GitHub Pages请看这篇文章~ 清除缓存文件和已生成的静态文件1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更改配置文件_config.yml后需要运行该命令。不然可能会报Unhandled rejection Error: ENOENT: no such file or directory, open &#39;**&#39;。 主题Hexo的默认主题是landscape，官方推荐主题：https://hexo.io/themes/ 本博客网站使用的主题是NexT.Pisces如需要v6及以上的，请看新仓库https://github.com/theme-next/hexo-theme-next 安装先从git将主题拉下来，在项目下1git clone https://github.com/iissnan/hexo-theme-next themes/next 在项目配置文件_config.yml中查找theme，修改值为theme: next。（注意next前的空格哦） 然后hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug就能看见next主题的默认样式啦 选择NexT.Pisces需要在themes/next下的主题配置文件_config.yml中查找scheme，修改值为scheme: Pisces再运行上面的重新启动，就能看到样式啦 安装Hexo和Next主题到此就结束啦~ 要说的话建议在项目下package.json中配置开发运行脚本和部署脚本，在最外层json中添加：1234"scripts": &#123; "dev": "hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug", "start": "hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy" &#125;, 以后开发运行npm run dev就好啦。线上部署使用npm run start。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webstorm .swig文件语法高亮]]></title>
    <url>%2F2019%2F03%2F07%2Fwebstorm-swig%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[前言swig是nodeJS前端模板引擎，swig特点看这里。 语法高亮webstrom（1）在File&gt;Settings&gt;Plugins，选择下方 Browse repositories... （2）在编辑框输入 twig，点击 Twig Support，Install之后重启webstorm （3）重启后，打开File&gt;Settings&gt;Editor&gt;File Types，找到Twig，点击+号添加*.swig，apply后就能看到.swig都高亮啦~]]></content>
      <tags>
        <tag>.swig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git出现The following problems have occurred when adding the files: *** is in submodule]]></title>
    <url>%2F2019%2F03%2F06%2Fgit%E5%87%BA%E7%8E%B0The-following-problems-have-occurred-when-adding-the-files-is-in-submodule%2F</url>
    <content type="text"><![CDATA[前言开始搭建博客的时候，使用到Next主题1git clone https://github.com/iissnan/hexo-theme-next themes/next clone下的项目内包含.git隐藏文件，删除后，更改主题的代码后提交报错，手动git add依然报错The following problems have occurred when adding the files: *** is in submodule 解决这是因为本来是其他git项目，需要清除缓存记录。1git rm -rf --cached themes/next 运行上面的代码之后，再git add就不会报错啦~]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android P报java.net.UnknownServiceException: CLEARTEXT communication to *** not permitted by netwo...]]></title>
    <url>%2F2019%2F03%2F06%2FAndroid-P%E6%8A%A5java-net-UnknownServiceException-CLEARTEXT-communication-to-not-permitted-by-netwo%2F</url>
    <content type="text"><![CDATA[原因由于 Android P 限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉。 如果当前应用的请求是 htttp 请求，而非 https ,这样就会导系统禁止当前应用进行该请求，如果 WebView 的 url 用 http 协议，同样会出现加载失败，https 不受影响。 为此，OkHttp3 做了检查，所以如果使用了明文流量，默认情况下，在 Android P 版本 OkHttp3 就抛出异常: CLEARTEXT communication to *** not permitted by network security policy 解决办法（任选一个）1.在 res 下新建一个 xml目录，然后创建一个名为：network_security_config.xml 文件 ，该文件内容如下：1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 然后在 AndroidManifest.xml application 标签内应用上面的xml配置：android:networkSecurityConfig=&quot;@xml/network_security_config&quot;123456&lt;application android:name=".app.App" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:networkSecurityConfig="@xml/network_security_config" android:label="@string/app_name" android:theme="@style/AppTheme"&gt; 2.服务器和本地应用都改用 https 3.targetSdkVersion 降级回到 27]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android P</tag>
      </tags>
  </entry>
</search>
